#!/usr/local/bin/perl

# The start of a gimme5 replacement based on STD parsing.
#
use strict;
use warnings;

use STD;
use utf8;
use YAML::XS;
use feature 'say';

my $OPT_pos = 0;
my $OPT_match = 0;
my $OPT_log = 0;
my $OPT_stab = 0;
my $PROG = '';
my @did_ws;

sub USAGE {
    print <<'END';
viv [switches] filename
    where switches can be:
    	-e	use following argument as program
    	--ast	spit out an abstract syntax tree (default)
    	--p5	spit out a Perl 5 representation (unimpl)
    	--p6	spit out a Perl 6 representation (partially impl)
    	--stab	include the symbol table
    	--pos	include position info in AST
    	--match	include match tree info in AST
    	--log	emit debugging info to standard error
END
    exit;
}


sub MAIN {
    my $output = 'ast';

    USAGE() unless @_;
    while (@_) {
	last unless $_[0] =~ /^-/;
	my $switch = shift @_;
	if ($switch eq '--eval' or $switch eq '-e') {
	    $PROG .= shift(@_) . "\n";
	}
	elsif ($switch eq '--ast' or $switch eq '-a') {
	    $output = 'ast';
	}
	elsif ($switch eq '--p5' or $switch eq '-5') {
	    $output = 'p5';
	}
	elsif ($switch eq '--p6' or $switch eq '-6') {
	    $output = 'p6';
	    $OPT_pos = 1;
	}
	elsif ($switch eq '--stab' or $switch eq '-s') {
	    $OPT_stab = 1;
	}
	elsif ($switch eq '--log' or $switch eq '-l') {
	    say @_;
	    $OPT_log = 1;
	}
	elsif ($switch eq '--pos' or $switch eq '-p') {
	    $OPT_pos = 1;	# attach position and prior ws len
	}
	elsif ($switch eq '--match' or $switch eq '-m') {
	    $OPT_match = 1;	# attach match object
	}
	elsif ($switch eq '--help') {
	    USAGE();
	}
    }
#    USAGE() unless -r $_[0];
    my $r;
    if (@_ and -f $_[0]) {
	$r = STD->parsefile($_[0], actions => 'Actions')->{'_'};
    }
    else {
	if (not $PROG) {
	    local $/;
	    @ARGV = @_;
	    $PROG = <>;
	}
	$r = STD->parse($PROG, actions => 'Actions')->{'_'};
    }
    delete $r->{CORE} unless $OPT_stab;
    if ($output eq 'ast') {
	print Dump($r);
    }
    elsif ($output eq 'p6') {
	print $r->ret($r->emit_p6);
    }
    elsif ($output eq 'p5') {
	print $r->emit_p5;
    }
    else {
	die "Unknown output mode";
    }
}

# viv should likely be abstracted into a module instead of doing this hack... - pmurias
sub VIV::SET_OPT {
    my %opt = @_;
    $OPT_pos = $opt{pos};
    $OPT_match = $opt{match};
    $OPT_log = $opt{log};
}

###################################################################

{ package Actions;

    # Generic ast translation done via autoload

    our $AUTOLOAD;
    my $SEQ = 1;

    sub AUTOLOAD {
	my $self = shift;
	my $match = shift;
	my $rule = shift()//0;
	return unless $rule;
	my $r = hoist($match);
	(my $class = $AUTOLOAD) =~ s/^Actions/VAST/;
	gen_class($class);
	bless $r, $class unless ref($r) =~ /^VAST/;
	$r->{MATCH} = $match if $OPT_match;
	$match->{'_'} = $r;
    }

    # propagate ->{'_'} nodes upward
    # (untransformed STD nodes in output indicate bugs)

    sub hoist {
	my $node = shift;
	my $text = $node->Str;
	my %r;
	my @all;
	my @fake;
	for my $k (keys %$node) {
	    #print STDERR $node->{_reduced}, " $k\n";
	    my $v = $node->{$k};
	    if ($k eq 'O') {
		for my $key (keys %$v) {
		    $r{$key} = $$v{$key};
		}
	    }
	    elsif ($k eq 'SIGIL') {
		$r{SIGIL} = $v;
	    }
	    elsif ($k eq 'sym') {
		if (ref $v) {
		    if (ref $v eq 'ARRAY') {
			$r{SYM} = ::Dump($v);
		    }
		    elsif (ref $v eq 'HASH') {
			$r{SYM} = ::Dump($v);
		    }
		    else {
			$r{SYM} = $v->Str;
		    }
		}
		else {
		    $r{SYM} = $v;
		}
	    }
	    elsif ($k eq '_arity') {
		$r{ARITY} = $v;
	    }
	    elsif ($k eq '~ALL') {
		for (@$v) {
		    push @all, $_->{'_'};
		}
	    }
	    elsif ($k eq 'nibbles') {
		@all =  @$v;
		for (@all) {
		    if (ref($_) eq 'HASH') {
			bless $_, 'VAST::TEXT';
		    }
		    elsif (exists $_->{'_'}) {
			$_ = $_->{'_'};
		    }
		}
		delete $node->{'~ALL'};
	    }
	    elsif ($k eq '_from') {
		if ($OPT_pos) {
		    $r{BEG} = $v;
		    $r{END} = $node->{_pos};
		}
		if (exists $::MEMOS[$v]{'ws'}) {
		    my $wsstart = $::MEMOS[$v]{'ws'};
		    $r{WS} = $v - $wsstart if defined $wsstart and $wsstart < $v
		}
	    }
	    elsif ($k =~ /^[a-zA-Z]/) {
		if (ref $v eq 'ARRAY') {
		    my $zyg = [];
		    for my $z (@$v) {
			if (ref $z) {
			    if (ref $z eq 'ARRAY') {
				push @$zyg, $z;
				push @fake, @$z;
			    }
			    elsif (exists $z->{'_'}) {
				my $zy = $z->{'_'};
				push @fake, $zy;
				push @$zyg, $zy;
			    }
			}
			else {
			    push @$zyg, $z;
			}
		    }
		    $r{$k} = $zyg;
#		    $r{zygs}{$k} = $SEQ++ if @$zyg and $k ne 'sym';
		}
		elsif (ref $v) {
		    if (exists $v->{'_'}) {
			push @fake, $v->{'_'};
			$r{$k} = $v->{'_'};
		    }
		    else {
			$r{$k} = $v;
		    }
#		    $r{zygs}{$k} = $SEQ++;
		    unless (ref($r{$k}) =~ /^VAST/) {
			my $class = "VAST::$k";
			gen_class($class);
			bless $r{$k}, $class;
		    }
		}
		else {
		    $r{$k} = $v;
		}
	    }
	}
	if (@all == 1 and defined $all[0]) {
	    $r{'.'} = $all[0];
	}
	elsif (@all) {
	    $r{'.'} = \@all;
	}
	elsif (@fake) {
	    $r{'.'} = \@fake;
	}
	else {
	    $r{TEXT} = $text;
	}
	\%r;
    }

    sub EXPR {
	my $self = shift;
	my $match = shift;
	my $r = hoist($match);
	(my $class = $r->{kind} // ref $r) =~ s/^STD/VAST/;
	gen_class($class);
	$match->{'_'} = bless $r, $class;
    }

    sub gen_class {
	my $class = shift;
	no strict 'refs';
	return if @{$class . '::ISA'};
	warn "Creating class $class\n" if $OPT_log;
	@{$class . '::ISA'} = 'VAST::Base';
    }

}

###################################################################

{ package VAST::Base;

    sub emit_p6 { my $self = shift;
	my $text = '';
	if (exists $self->{'.'}) {
	    my $last = $self->{BEG};
	    my $all = $self->{'.'};
	    my @kids;
	    for my $kid (ref $all eq 'ARRAY' ? @$all : $all) {
		next unless $kid;
		if (not defined $kid->{BEG}) {
		    $kid->{BEG} = $kid->{_from} // next;
		    $kid->{END} = $kid->{_pos};
		}
		push @kids, $kid;
	    }
	    for my $kid (sort { $a->{BEG} <=> $b->{BEG} } @kids) {
		my $kb = $kid->{BEG};
		next unless defined $kb;
		if (not defined $kb) {
		    warn ref($kid) . " has no BEG!!!\n";
		    return $self->ret($self->{TEXT} // '???NOBEG???');
		}
		if ($kb > $last) {
		    $text .= substr($::ORIG, $last, $kb - $last);
		}
		$text .= $kid->emit_p6();
		$last = $kid->{END};

	    }
	    my $se = $self->{END};
	    if ($se > $last) {
		    $text .= substr($::ORIG, $last, $se - $last);
	    }
	    return $self->ret($text);
	}
	else {
	    my $text = $self->{TEXT};
	    return $self->ret($text);
	    my $last = $self->{BEG};
	    my $se = $self->{END};
	    if ($se > $last) {
		    $text .= substr($::ORIG, $last, $se - $last);
	    }
	    return $self->ret($text);
	}
    }

    sub ret { my $self = shift;
	warn ref $self, " returns ", $_[0], "\n" if $OPT_log;
	$_[0];
    }


#    sub get_ws { my $self = shift;
#	return '';
#	my $ws = $self->{WS} // 0;
#	my $pos = $self->{BEG};
#	if ($ws and not $did_ws[$pos]++) {
#	    substr($::ORIG, $pos - $ws, $ws)
#	}
#	else {
#	    '';
#	}
#    }
	
}

{ package VAST::sample; our @ISA = 'VAST::Base';
}

{ package VAST::TEXT; our @ISA = 'VAST::Base'; }

{ package VAST::comp_unit; our @ISA = 'VAST::Base';
    sub emit_p6 { my $self = shift;
	$self->ret($self->{statementlist}->emit_p6);
    }

}

if ($0 eq __FILE__) {
    ::MAIN(@ARGV);
}

# vim: ts=8 sw=4 noexpandtab smarttab
