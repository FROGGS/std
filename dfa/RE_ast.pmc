# RE_ast.pmc
#
# Copyright 2009-2010, Larry Wall
#
# You may copy this software under the terms of the Artistic License,
#     version 2.0 or later.

package main;
use utf8;
use strict; use warnings;
use DEBUG;
use Encode;
my $DIMP = [[{I=>1}, [[1]] ]];
my $DNULL = [[undef, [[0]] ]];

# The DFA engine has two priorities; top priority is to generate the correct
# pattern prefixes; second is to generate as much fate as it can.

# [conjectural]
# We use two data structures to represent NFAs.  The NFA description tree
# (NFA::* but not NFA::Node, NFA::Lazy) is statically built; it is a near 1:1
# mapping of the RE_ast structure.  The NFA description tree is used to
# generate the NFA construction tree, which is lazily built.
{
    package NFA::Lazy;
    sub new   { bless [ @_ ], 'NFA::Lazy' }
    sub reify {
        my $self = shift;
        my ($node, $prefix, $continue) = splice @$self;
        bless $self, 'NFA::Node';
        $node->construct($self, $prefix, $continue);
    }
}

{
    package NFA::Node;
    sub reify { }
}

{
    package NFA::seq;
    sub new {
        my ($left, $right) = @_;
        my $literal = $left->{literal};
        my $litlen  = $left->{litlen};
        if ($literal) {
            $literal &&= $right->{literal};
            $litlen  +=  ($right->{litlen} // 0);
        }
        bless { left => $left, right => $right, literal => $literal,
            litlen => $litlen, fates => ($left->{fates} || $right->{fates}) },
            'NFA::seq';
    }

    sub construct {
        my ($self, $node, $pre_fates, $continue) = @_;

        $self->{left}->construct($node, $pre_fates, sub {
                my $mid_fates = shift;
                NFA::Lazy->new($self->{right}, $mid_fates, $continue);
            });
    }
}

#############################################################
# longest token set generator
#############################################################

#    $::DEBUG |= -1;
sub qm { my $s = shift;
    $s = $s->[0] if ref $s eq 'ARRAY';	# only count first token of circumfix or postcircumfix
    my $r = '';
    for (split(//,$s)) {
	if ($_ eq " ") { $r .= '\x20' }
	elsif ($_ eq "\t") { $r .= '\t' }
	elsif ($_ eq "\n") { $r .= '\n' }
	elsif ($_ =~ m/^\w$/) { $r .= $_ }
	elsif ($_ eq '<' | $_ eq '>') { $r .= $_ }
	else { $r .= '\\' . $_ }
    }
    $r;
}

sub here {
    return unless $::DEBUG & DEBUG::longest_token_pattern_generation;
    my $arg = shift;
    my $lvl = 0;
    while (caller($lvl)) { $lvl++ }
    my ($package, $file, $line, $subname, $hasargs) = caller(0);

    my $name = $package;   # . '::' . substr($subname,1);
    if (defined $arg) { 
	$name .= " " . $arg;
    }
    ::deb("\t", ':' x $lvl, ' ', $name, " [", $file, ":", $line, "]") if $::DEBUG & DEBUG::longest_token_pattern_generation;
}

sub nfarebase { my ($onto, $ary) = @_;
    my $offs = @$onto;

    for my $node (@$ary) {
        my $nnode = [ @$node ];
        for (my $ix = 3; $ix < @$nnode; $ix += 2) {
            $nnode->[$ix] += $offs;
        }
        push @$onto, $nnode;
    }

    $offs;
}

sub nfaprefate { my ($fates, $nfa) = @_;
    my @out = @$nfa;

    for my $onode (@out) {
        $onode = [ @$onode ];
        # Non-accepting can just be copied
        next unless @{$onode->[1]};

        my @nfates;
        for my $f1 (@$fates) {
            if ($f1->[-1]) {
                # Non-extensible fate makes this easy
                push @nfates, $f1;
                next;
            }
            my @f1 = @$f1;
            pop @f1;
            for my $f2 (@{$onode->[1]}) {
                push @nfates, [ @f1, @$f2 ];
            }
        }

        $onode->[1] = \@nfates;
    }

    \@out;
}

sub nfaltmprefate { my ($tag, $val, $tb, $inner) = @_;
    my $ord = pack("NN", (~($inner->[0][0]{LITLEN} // 0)), $tb);
    nfaprefate([[ $tag, $val, $ord, 0 ]], $inner);
}

# When a non-LTM alternation or quantifier is applied to a subregex, it becomes
# impossible to control fate usage, so we can't dispense them.  But it's ok to
# keep the fates if they're all trivial (and this is useful anyway, to prevent
# x* and the like from blocking lexer propagation)
sub nfahasnontrivialfates { my ($inner) = @_;
    my $ok = 1;
    NODE: for my $n (@$inner) {
        for my $fate (@{ $n->[1] }) {
            if ((@$fate > 1) || $fate->[0]) {
                $ok = 0;
                last NODE;
            }
        }
    }
    !$ok;
}

sub nfaseq { my ($fst, $sndthunk) = @_;
    my @out = @$fst;
    my $max = @out - 1;

    if (ref $sndthunk ne 'CODE') {
        my $v = $sndthunk;
        $sndthunk = sub { $v };
    }

    for my $j (0 .. $max) {
        # Non-accepting can just be copied
        next unless @{$out[$j][1]};
        $out[$j] = [ @{ $out[$j] } ];
        # Imperative acceptors stay accepting and in the same way
        next if $out[$j][0]{I};
        # Otherwise, we need to glue on a copy of the sequence tail.
        # We could share a single copy of the sequence tail if we were
        # willing to lose deep fating... food for thought.
        push @{$out[$j]}, undef, nfarebase(\@out,
            nfaprefate($out[$j][1], $sndthunk->()));
        $out[$j][1] = [];  # not accepting any more
    }

    if ($out[0][0]{LITERAL}) {
        $out[0][0] = { %{ $out[0][0] } } if $out[0][0];
        my $n = $sndthunk->()->[0][0];
        $out[0][0]{LITERAL} &&= $n->{LITERAL};
        $out[0][0]{LITLEN} += ($n->{LITLEN} // 0);
    }

    \@out;
}

# nfaplus would be possible, but it would be a pessimization from a deep fating
# standpoint
sub nfastar { my ($in) = @_;
    my @out = ( [undef, []] );
    nfarebase(\@out, $in);
    my $fates = [[ nfahasnontrivialfates($in) ]];

    # all nodes already cloned by nfarebase
    for my $node (@out) {
        next unless @{ $node->[1] };
        if ($node->[0]{I}) {
            $node->[1] = $fates;
            next;
        }
        $node->[1] = [];
        push @$node, undef, 0;
    }

    $out[0][1] = $fates;
    push @{ $out[0] }, undef, 1;
    \@out;
}

sub nfaopt { my ($in) = @_;
    my @out = ( [undef, [], undef, 1, undef, 2], [undef, []] );

    my $fates = [[ nfahasnontrivialfates($in) ]];
    nfarebase(\@out, $in);

    # all nodes already cloned by nfarebase
    for my $node (@out) {
        next unless @{ $node->[1] };
        if ($node->[0]{I}) {
            $node->[1] = $fates;
            next;
        }
        $node->[1] = [];
        push @$node, undef, 1;
    }

    $out[1][1] = $fates;
    \@out;
}

sub nfadisj { my @ins = @_;
    my @out = ( [ undef, [] ] );

    for my $in (@ins) {
        push @{ $out[0] }, undef, nfarebase(\@out, $in);
    }

    \@out;
}

sub nfacclass { my @terms = @_;
    return [ [ undef, [], map { $_, 1 } @terms ],
             [ undef, [[0]] ] ];
}

sub nfastring { my ($i, $text) = @_;
    my @nfa;
    for my $c (split //, $text) {
        my @e = $i ? (lc($c), uc($c)) : ($c);
        push @nfa, [ undef, [], map {[$_], @nfa+1} @e ];
    }
    $nfa[0][0]{LITERAL} = 1;
    $nfa[0][0]{LITLEN} = length($text);
    [ @nfa, [ undef, [[0]] ] ];
}

{ package REbase;
}

{ package RE_ast; our @ISA = 'REbase';
    sub nfa { my $self = shift; my $C = shift;
        ::here();
        $self->{'re'}->nfa($C);
    }
}

{ package RE_assertion; our @ISA = 'REbase';
    sub nfa { my ($self, $C) = @_;
        if ($self->{assert} eq '?') {
            my $re = $self->{re};
            return ::nfaseq($re->nfa($C), $DIMP);
        }
        return $DNULL;
    }
}

{ package RE_assertvar; our @ISA = 'REbase';
    sub nfa { $DIMP }
}

{ package RE_block; our @ISA = 'REbase';
    sub nfa { $DIMP }
}

{ package RE_bindvar; our @ISA = 'REbase';
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'atom'}->nfa($C);
    }
}

{ package RE_bindnamed; our @ISA = 'REbase';
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'atom'}->nfa($C);
    }
}

{ package RE_bindpos; our @ISA = 'REbase';
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'atom'}->nfa($C);
    }
}

{ package RE_bracket; our @ISA = 'REbase';
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'re'}->nfa($C);
    }
}

{ package RE_cclass; our @ISA = 'REbase';
    sub _get_char {
        if ($_[0] =~ s/^([^\\])//s) { return ord($1) }
        if ($_[0] =~ s/^\\n//)   { return 10 }
        if ($_[0] =~ s/^\\t//)   { return 9 }
        if ($_[0] =~ s/^\\x\{(.*?)\}//s)   { return hex($1); }
        if ($_[0] =~ s/^\\x(..)//s)   { return hex($1); }
        if ($_[0] =~ s/^\\(.)//s)   { return ord($1) }

        return undef;
    }

    sub nfa { my ($self, $C) = @_; ::here($self->{text});
        $CursorBase::fakepos++;
        my $cc = $self->{'text'};
        Encode::_utf8_on($cc);
        my ($neg, $text) = $cc =~ /^(-?)\[(.*)\]$/s;
        die "whoops! $cc" unless defined $text;

        #XXX this ought to be pre parsed
        my ($ch, $ch2);
        my @chs;
        while (1) {
            $text =~ s/^\s+//;
            if ($text =~ s/^\\s//) {
                push @chs, 'Space/Y';
                next;
            }
            if ($text =~ s/^\\w//) {
                push @chs, '_', 'Gc/L', 'Gc/N';
                next;
            }
            last if $text eq '';
            $ch = _get_char($text);
            if ($text =~ s/^\s*\.\.//) {
                $ch2 = _get_char($text);
            } else {
                $ch2 = $ch;
            }
            push @chs, map { chr $_ } ($ch .. $ch2);
        }

        if ($self->{i}) {
            @chs = map { uc($_), lc($_) } @chs;
        }

        $neg ? ::nfacclass(['ALL', @chs]) : ::nfacclass(map { [$_] } @chs);
    }
}

{ package RE_decl; our @ISA = 'REbase';
    sub nfa { $DNULL }
}

{ package RE_double; our @ISA = 'REbase';
    # XXX inadequate for "\n" without interpolation
    sub nfa { my ($self, $C) = @_;
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        $Cursor::fakepos++ if $text ne '';
        my ($fixed, $imp);
        if ( $text =~ /^(.*?)[\$\@\%\&\{]/ ) {
            $fixed = $1; $imp = 1;
        }
        else {
            $fixed = $text;
        }
        $fixed = ::nfastring($self->{i}, $fixed);
        $fixed = ::nfaseq($fixed, $DIMP) if $imp;
        $fixed;
    }
}

{ package RE_meta; our @ISA = 'REbase';
    my %meta_nfa = (
        # XXX I don't think these are quite right
        '^' => $DNULL, '^^' => $DNULL, '$$' => $DNULL, '$' => $DNULL,
        '«' => $DNULL, '<<' => $DNULL, '>>' => $DNULL, '»' => $DNULL,
        # what?
        '\\\\' => ::nfacclass(['\\']),
        '\\"' => ::nfacclass(['"']),
        '\D' => ::nfacclass(['ALL', 'Gc/N']),
        '\d' => ::nfacclass(['Gc/N']),
        '\H' => ::nfacclass(['ALL', 'Perl/Blank']),
        '\h' => ::nfacclass(['Perl/Blank']),
        '\N' => ::nfacclass(['ALL', "\n"]),
        '\n' => ::nfacclass(["\n"]),
        '\S' => ::nfacclass(['ALL', 'Space/Y']),
        '\s' => ::nfacclass(['Space/Y']),
        '\V' => ::nfacclass(['ALL', 'Perl/VertSpac']),
        '\v' => ::nfacclass(['Perl/VertSpac']),
        '\W' => ::nfacclass(['ALL', '_', 'Gc/L', 'Gc/N']),
        '\w' => ::nfacclass(['_'], ['Gc/L'], ['Gc/N']),
        '.'  => ::nfacclass(['ALL']),
        '::' => $DIMP,
        ':::' => $DIMP,
        '.*?' => $DIMP,
        '.*' => [ [ undef, [[0]], ['ALL'], 0 ] ],
    );

    sub nfa { my $self = shift; my ($C) = @_; 
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        return $meta_nfa{$text} // die "unhandled meta $text";
    }
}

{ package RE_method; our @ISA = 'REbase';
    sub nfa { my ($self, $C) = @_;
        my $name = $self->{'name'};
        return $DIMP if $self->{'rest'};
        Encode::_utf8_on($name);
        ::here($name);

        if ($name eq 'null' or $name eq 'ww') { return $DNULL }
        if ($name eq 'ws') { return $DIMP; }
        if ($name eq 'alpha') { $CursorBase::fakepos++; return ::nfacclass(['_'], ['Gc/L']); }
        if ($name eq 'sym') {
            $CursorBase::fakepos++;
            my $sym = $self->{'sym'};
            Encode::_utf8_on($sym);
            return ::nfastring($self->{i}, $sym);
        }

        # XXX
        $name = 'termish' if $name eq 'EXPR';

        $::usedmethods{$name} = 1;
        $name .= '__PEEK';
        return $DIMP unless $C->can($name);
        my $lexer = $C->$name();
        %::usedmethods = (%::usedmethods, %{ $lexer->{USED_METHODS} });
        return $DIMP unless $lexer and exists $lexer->{NFA};
        return $lexer->{NFA};
    }
}

{ package RE_method_internal; our @ISA = 'REbase';
    sub nfa { $DIMP }
}

{ package RE_method_re; our @ISA = 'REbase';
    sub nfa { my ($self, $C) = @_;
        my $name = $self->{name};
        Encode::_utf8_on($name);
        ::here($name);
        my $re = $self->{re};
        if ($name eq '') {
            return $DIMP;
        } elsif ($name eq 'after') {
            return $DNULL;
        } elsif ($name eq 'before') {
            return ::nfaseq($re->nfa($C), $DIMP);
        } else {
            $::usedmethods{$name} = 1;
            $name .= '__PEEK';
            my $lexer = $C->$name($re);
            %::usedmethods = (%::usedmethods, %{ $lexer->{USED_METHODS} });
            return $lexer->{NFA};
        }
    }
}

{ package RE_noop; our @ISA = 'REbase';
    sub nfa { $DNULL }
}

{ package RE_every; our @ISA = 'REbase';
    sub nfa { $DIMP }
}

{ package RE_first; our @ISA = 'REbase';
    sub nfa { my ($self, $C) = @_;
        my $alts = $self->{'zyg'};
        ::here(0+@$alts);
        # block fate propagation
        ::nfaprefate([[1]], $alts->[0]->nfa($C));
    }
}

{ package RE_paren; our @ISA = 'REbase';
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'re'}->nfa($C);
    }
}

{ package RE_quantified_atom; our @ISA = 'REbase';
    sub nfa { my ($self, $C) = @_; ::here();
        my $oldfakepos = $CursorBase::fakepos++;
        my $subnfa = $self->{atom}->nfa($C);
        #return $DIMP if $self->{quant}[1];  XXX viv omits this currently
        # XXX S05 is not quite clear; it could be read as saying to cut LTM
        # *after* the atom
        return $DIMP if $self->{quant}[2]
            && $self->{quant}[2]->isa('RE_block');

        my $k = $self->{quant}[0];
        if ($k eq '?') {
            return ::nfaopt($subnfa);
        } elsif ($k eq '*') {
            return ::nfastar($subnfa);
        } elsif ($k eq '+') {
            return ::nfaseq($subnfa, ::nfastar($subnfa));
        } elsif ($k eq '**') {
            my $subnfa2 = $self->{quant}[2]->nfa($C);
            return ::nfaseq($subnfa, ::nfastar(::nfaseq($subnfa2, $subnfa)));
        } else {
            die "unknown quantifier $k";
        }
    }
}

{ package RE_qw; our @ISA = 'REbase';
    sub nfa { my ($self, $C) = @_;
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        $CursorBase::fakepos++;
        $text =~ s/^<\s*//;
        $text =~ s/\s*>$//;

        ::nfadisj(map { ::nfastring($self->{i}, $_) } split(/\s+/, $text));
    }
}

{ package RE_sequence; our @ISA = 'REbase';
    sub _nfa_recurse { my ($self, $C, $ix, $cache) = @_;
        if ($ix == @{$self->{zyg}}) {
            return $DNULL;
        }

        ::nfaseq($self->{zyg}[$ix]->nfa($C),
            sub { $cache->[$ix+1] //= $self->_nfa_recurse($C, $ix+1, $cache); });
    }

    sub nfa { my ($self, $C) = @_; ::here;
        my @cache;
        $self->_nfa_recurse($C, 0, \@cache);
    }
}

{ package RE_string; our @ISA = 'REbase';
    sub nfa { my ($self, $C) = @_;
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        $CursorBase::fakepos++ if $text ne '';
        ::nfastring($self->{i}, $text);
    }
}

{ package RE_submatch; our @ISA = 'REbase';
    sub nfa { $DIMP }
}

{ package RE_all; our @ISA = 'REbase';
    sub nfa { $DIMP }
}

{ package RE_any; our @ISA = 'REbase';
    sub nfa { my $self = shift; my ($C) = @_; 
        my $alts = $self->{'zyg'};
        ::here(0+@$alts);
        my @outs;
        my $oldfakepos = $CursorBase::fakepos;
        my $minfakepos = $CursorBase::fakepos + 1;
        my $ix = 0;
        
        for my $alt (@$alts) {
            $CursorBase::fakepos = $oldfakepos;

            push @outs, ::nfaltmprefate($self->{altname}, $ix, $ix, $alt->nfa($C));

            $minfakepos = $oldfakepos if $CursorBase::fakepos == $oldfakepos;
            $ix++;
        }
        $CursorBase::fakepos = $minfakepos;  # Did all branches advance?
        ::nfadisj(@outs);
    }
}

{ package RE_var; our @ISA = 'REbase';
    sub nfa { my ($self, $C) = @_;
        my $var = $self->{var};
        if (my $p = $C->_PARAMS) {
            my $text = $p->{$var} || return $DIMP;
            $CursorBase::fakepos++ if length($text);
            return ::nfastring($self->{i}, $text);
        }
        return $DIMP;
    }
}

1;
