# RE_ast.pmc
#
# Copyright 2009-2010, Larry Wall
#
# You may copy this software under the terms of the Artistic License,
#     version 2.0 or later.

package main;
use utf8;
use strict; use warnings;
use DEBUG;
use Encode;
my $IMP = '(?#::)';
my $DIMP = [1, [[1]] ];
our $PURIFY = 0;        # ignore {*} IMPs?
our $PREFIX = "";

# The DFA engine has two priorities; top priority is to generate the correct
# pattern prefixes; second is to generate as much fate as it can.

#############################################################
# longest token set generator
#############################################################

#    $::DEBUG |= -1;
sub qm { my $s = shift;
    $s = $s->[0] if ref $s eq 'ARRAY';	# only count first token of circumfix or postcircumfix
    my $r = '';
    for (split(//,$s)) {
	if ($_ eq " ") { $r .= '\x20' }
	elsif ($_ eq "\t") { $r .= '\t' }
	elsif ($_ eq "\n") { $r .= '\n' }
	elsif ($_ =~ m/^\w$/) { $r .= $_ }
	elsif ($_ eq '<' | $_ eq '>') { $r .= $_ }
	else { $r .= '\\' . $_ }
    }
    $r;
}

sub here {
    return unless $::DEBUG & DEBUG::longest_token_pattern_generation;
    my $arg = shift;
    my $lvl = 0;
    while (caller($lvl)) { $lvl++ }
    my ($package, $file, $line, $subname, $hasargs) = caller(0);

    my $name = $package;   # . '::' . substr($subname,1);
    if (defined $arg) { 
	$name .= " " . $arg;
    }
    ::deb("\t", ':' x $lvl, ' ', $name, " [", $file, ":", $line, "]") if $::DEBUG & DEBUG::longest_token_pattern_generation;
}

sub nfarebase { my ($onto, $ary) = @_;
    my $offs = @$onto;

    for my $node (@$ary) {
        for (my $ix = 3; $ix < @$node; $ix += 2) {
            $node->[$ix] += $offs;
        }
        push @$onto, $node;
    }

    $offs;
}

{ package REbase;
    sub longest { my $self = shift; my ($C) = @_;  ::here("UNIMPL @{[ref $self]}"); "$self" }
}

{ package RE_ast; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        ::here();
        local $::ALT = '';
        $self->{'re'}->longest($C);
    }

    sub nfa { my $self = shift; my $C = shift;
        ::here();
        $self->{'re'}->nfa($C);
    }
}

{ package RE_adverb; our @ISA = 'REbase';
    #method longest ($C) { ... }
}

{ package RE_assertion; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        for (scalar($self->{'assert'})) { if ((0)) {}
            elsif ($_ eq '?') {
                my $re = $self->{'re'};
#               $C->deb("\n",::Dump($self)) unless $re;
                if (ref($re) eq 'RE_method_re' and $re->{'name'} eq 'before') {
                    my @result = $re->longest($C);
                    return map { $_ . $IMP } @result;
                }
            }
        }
        return '';
    }
}

{ package RE_assertvar; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        return $IMP;
    }
    sub nfa { $DIMP }
}

{ package RE_block; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        return '' if $PURIFY;
        return $IMP;
    }
    sub nfa { $DIMP }
}

{ package RE_bindvar; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; ::here();
        $self->{'atom'}->longest($C);
    }
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'atom'}->nfa($C);
    }
}

{ package RE_bindnamed; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; ::here();
        $self->{'atom'}->longest($C);
    }
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'atom'}->nfa($C);
    }
}

{ package RE_bindpos; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; ::here();
        $self->{'atom'}->longest($C);
    }
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'atom'}->nfa($C);
    }
}

{ package RE_bracket; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; ::here();
        $self->{'re'}->longest($C);
    }
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'re'}->nfa($C);
    }
}

{ package RE_cclass; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; ::here($self->{'text'});
        $CursorBase::fakepos++;
        my $cc = $self->{'text'};
        Encode::_utf8_on($cc);
        $cc =~ s/^\-\[/[^/;
        $cc =~ s/^\+\[/[/;
        $cc =~ s/\s*\.\.\s*/-/g;
        $cc =~ s/\s*//g;
        $cc = "(?i:$cc)" if $self->{i};
        $cc;
    }
}

{ package RE_decl; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_;  return; }
}

{ package RE_double; our @ISA = 'REbase';
    # XXX inadequate for "\n" without interpolation
    sub longest { my $self = shift; my ($C) = @_; 
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        my $fixed = '';
        if ( $text =~ /^(.*?)[\$\@\%\&\{]/ ) {
            $fixed = $1 . $IMP;
        }
        else {
            $fixed = $text;
        }
        if ($fixed ne '') {
            $CursorBase::fakepos++;
            ::qm($fixed);
        }
        $fixed =~ s/([a-zA-Z])/'[' . $1 . chr(ord($1)^32) . ']'/eg if $self->{i};
        $fixed;
    }
}

{ package RE_meta; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        for (scalar($text)) { if ((0)) {}
            elsif ($_ eq '^' or
                   $_ eq '$' or
                   $_ eq '.' or
                   $_ eq '\\w' or
                   $_ eq '\\s' or
                   $_ eq '\\d')
            {
                return $text;
            }
            elsif ($_ eq '\\h') {
                return '[\\x20\\x09\\x0d]';
            }
            elsif ($_ eq '\\v') {
                return '[\\x0a\\x0c]';
            }
            elsif ($_ eq '\\N') {
                return '[^\\x0a]';
            }
            elsif ($_ eq '$$') {
                return '(?:\\x0a|$)';
            }
            elsif ($_ eq ':' or $_ eq '^^') {
                return;
            }
            elsif ($_ eq '»' or $_ eq '>>') {
                return '\b';
            }
            elsif ($_ eq '«' or $_ eq '<<') {
                return '\b';
            }
            elsif ($_ eq '::' or $_ eq ':::' or $_ eq '.*?') {
                return $IMP;
            }
            else {
                return $text;
            }
        }
    }
}

{ package RE_method; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        my $name = $self->{'name'};
        return $IMP if $self->{'rest'};
        Encode::_utf8_on($name);
        ::here($name);
        for (scalar($name)) { if ((0)) {}
            elsif ($_ eq 'null') {
                return;
            }
            elsif ($_ eq '') {
                return $IMP;
            }
            elsif ($_ eq 'ws') {
                return $IMP;
            }
            elsif ($_ eq 'sym') {
                $CursorBase::fakepos++;
                my $sym = $self->{'sym'};
                Encode::_utf8_on($sym);
                my $text = ::qm($sym);
                $text =~ s/(\pL)/'[' . lc($1) . uc($1) . ']'/eg if $self->{i};
                return $text;
            }
            elsif ($_ eq 'ww') {
                return '\w' . $IMP;
            }
            elsif ($_ eq 'alpha') {
                $CursorBase::fakepos++;
                return '[_[:alpha:]\pL]';
            }
            my $lexer;
            {
                local $::PREFIX = "";
                $name .= '__PEEK';
                $lexer = eval { $C->$name() };
            }
            return $IMP unless $lexer and exists $lexer->{PATS};
            my @pat = @{$lexer->{PATS}};
            return unless @pat;
            if ($::PREFIX) {
                for (@pat) {
                    s/(\t\(\?#FATE)\d* *(.*?\))(.*)/$3$1$::PREFIX $2/g;
                }
            }
            return @pat;
        }
    }
    sub nfa { my ($self, $C) = @_;
        my $name = $self->{'name'};
        return $IMP if $self->{'rest'};
        Encode::_utf8_on($name);
        ::here($name);

        $name .= '__PEEK';
        my $lexer = eval { $C->$name() };
        return $DIMP unless $lexer and exists $lexer->{DFA}{NFA};
        return @{$lexer->{DFA}{NFA}};
    }
}

{ package RE_method_internal; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        return $IMP;
    }
    sub nfa { $DIMP }
}

{ package RE_method_re; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        my $name = $self->{'name'};
        Encode::_utf8_on($name);
        ::here($name);
        my $re = $self->{'re'};
        for (scalar($name)) { if ((0)) {}
            elsif ($_ eq '') {
                return $IMP;
            }
            elsif ($_ eq 'after') {
                return;
            }
            elsif ($_ eq 'before') {
                my @result = $re->longest($C);
                return map { $_ . $IMP } @result;
            }
            else {
                $name .= '__PEEK';
                my $lexer = $C->$name($re);
                my @pat = @{$lexer->{PATS}};
                return unless @pat;
                return @pat;
            }
        }
    }
}

{ package RE_noop; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        return $IMP;
    }
}

{ package RE_every; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        return $IMP;
    }
    sub nfa { $DIMP }
}

{ package RE_first; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        my $alts = $self->{'zyg'};
        ::here(0+@$alts);
        my @result;
        for my $alt (@$alts) {
            my @pat = $alt->longest($C);
            push @result, @pat;
            last;
        }
        $C->deb(join("\n",@result)) if $::DEBUG & DEBUG::longest_token_pattern_generation;
        @result;
    }
}

{ package RE_paren; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; ::here();
        $self->{'re'}->longest($C);
    }
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'re'}->nfa($C);
    }
}

{ package RE_quantified_atom; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        ::here();
        my $oldfakepos = $CursorBase::fakepos++;
        my $a = $self->{atom};
        my @atom = $a->longest($C);
        return unless @atom;
        my $atom = join('|',@atom);
        return if $atom eq '';
        $atom = "(?:" . $atom . ')' unless $a->{min} == 1 and ref($a) =~ /^RE_(?:meta|cclass|string)/;
        if ($self->{'quant'}[0] eq '+') {
            if (@atom > 1) {
                return map { $_ . $IMP } @atom;
            }
            return "$atom+";
        }
        elsif ($self->{'quant'}[0] eq '*') {
            $CursorBase::fakepos = $oldfakepos;
            if (@atom > 1) {
                return map { $_ . $IMP } @atom,'';
            }
            return "$atom*";
        }
        elsif ($self->{'quant'}[0] eq '?') {
            $CursorBase::fakepos = $oldfakepos;
            if (@atom > 1) {
                return @atom,'';
            }
            return "$atom?";
        }
        elsif ($self->{'quant'}[0] eq '**') {
            my $x = $self->{'quant'}[2];
            if ($x =~ /^\d/) {
                $x =~ s/\.\./,/;
                $x =~ s/\*//;
                $CursorBase::fakepos = $oldfakepos if $x =~ m/^0/;
                return $atom . "{$x}";
            }
            else {
                return $atom . $IMP;
            }
        }
        return $IMP;
    }
}

{ package RE_qw; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        $CursorBase::fakepos++;
        $text =~ s/^<\s*//;
        $text =~ s/\s*>$//;
        $text =~ s/\s+/|/;
        '(?: ' . $text . ')';
    }
}

{ package RE_sequence; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        my $result = [''];
        my $c = $self->{'zyg'};
        my @chunks = @$c;
        ::here(0+@chunks);
        local $::PREFIX = $::PREFIX;

        for my $chunk (@chunks) {
            # ignore negative lookahead
            next if ref($chunk) eq 'RE_assertion' and $chunk->{assert} eq '!';
            $C->deb("NULLABLE ".ref($chunk)) if $::DEBUG & DEBUG::longest_token_pattern_generation and not $chunk->{min};
            my @newalts = $chunk->longest($C);
            last unless @newalts;
#           if (not $chunk->{min} and $next[-1] ne '') {
#               push(@next, '');        # install bypass around nullable atom
#           }
            my $newresult = [];
            my $pure = 0;
            for my $oldalt (@$result) {
                if ($oldalt =~ /\(\?#::\)/) {
                    push(@$newresult, $oldalt);
                    next;
                }

                for my $newalt (@newalts) {
                    $pure = 1 unless $newalt =~ /\(\?#::\)/;
#                   $::PREFIX = '' if $newalt =~ /FATE/;;
                    if ($oldalt =~ /FATE/ and $newalt =~ /FATE/) {
                        my $newold = $oldalt;
                        my $newnew = $newalt;
                        $newnew =~ s/\t\(\?#FATE\d* *(.*?)\)//;
                        my $morefate = $1;
                        $newold =~ s/(FATE.*?)\)/$1 $morefate)/;
                        push(@$newresult, $newold . $newnew);
                    }
                    else {
                        push(@$newresult, $oldalt . $newalt);
                    }
                }
            }
            $result = $newresult;
            last unless $pure;  # at least one alternative was pure
            # ignore everything after positive lookahead
            last if ref($chunk) eq 'RE_assertion';
        }
        @$result;
    }

    sub _nfa_recurse { my ($self, $C, $cache, $ix, $fates) = @_;
        if ($ix == @{$self->{zyg}}) {
            return [ 0, $fates ];
        }

        my $orig = $cache->[$ix] //= [$self->{zyg}[$ix]->nfa($C)];
        my @out = @$orig;
        my $max = @out - 1;

        for my $j (0 .. $max) {
            # Non-accepting can just be copied
            next unless @{$out[$j][1]};
            # Imperative acceptors stay accepting and in the same way
            next if $out[$j][0];
            # Otherwise, we need to glue on a copy of the sequence tail.
            # We could share a single copy of the sequence tail if we were
            # willing to lose deep fating... food for thought.
            my @nfates;
            for my $f1 (@$fates) {
                if ($f1->[-1]) {
                    # Non-extensible fate makes this easy
                    push @nfates, $f1;
                    next;
                }
                my @f1 = @$f1;
                pop @f1;
                for my $f2 (@{$out[$j][1]}) {
                    push @nfates, [ @f1, @$f2 ];
                }
            }
            my @rest = $self->_nfa_recurse($C, $cache, $ix+1, \@nfates);
            push @{$out[$j]}, '', ::nfarebase(\@out, \@rest);;
            $out[$j][1] = [];
        }

        @out;
    }

    sub nfa { my ($self, $C) = @_; ::here;
        my @cache;
        $self->_nfa_recurse($C, \@cache, 0, [[0]]);
    }
}

{ package RE_string; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        $CursorBase::fakepos++ if $self->{'min'};
        $text = ::qm($text);
        $text =~ s/([[:alpha:]])/'[' . $1 . chr(ord($1)^32) . ']'/eg if $self->{i};
        $text;
    }
    sub nfa { my ($self, $C) = @_;
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        $CursorBase::fakepos++ if $self->{'min'};
        die "UNIMPL" if $self->{i};
        my @nfa;
        for (split //, $text) {
            push @nfa, [ 0, [], $_, @nfa+1 ];
        }
        @nfa, [ 0, [[0]] ];
    }
}

{ package RE_submatch; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        return $IMP;
    }
    sub nfa { $DIMP }
}

{ package RE_all; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        return $IMP;
    }
    sub nfa { $DIMP }
}

{ package RE_any; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        my $alts = $self->{'zyg'};
        ::here(0+@$alts);
        my @result;
        my $oldfakepos = $CursorBase::fakepos;
        my $minfakepos = $CursorBase::fakepos + 1;
        my $base = $::ALT // '';
        $base .= ' ' if $base;
        my %autolexbase = %::AUTOLEXED;
        for my $alt (@$alts) {
            local %::AUTOLEXED = %autolexbase;    # alts are independent
            $CursorBase::fakepos = $oldfakepos;
            local $::ALT = $base . $alt->{alt};
            {
                local $::PREFIX = $::PREFIX . ' ' . $::ALT;
                my @pat = ($alt->longest($C));
                push @result, map { /#FATE/ or s/$/\t(?#FATE $::PREFIX)/; $_ } @pat;
            }
            $minfakepos = $oldfakepos if $CursorBase::fakepos == $oldfakepos;
        }
        $C->deb(join("\n", @result)) if $::DEBUG & DEBUG::longest_token_pattern_generation;
        $CursorBase::fakepos = $minfakepos;  # Did all branches advance?
        @result;
    }

    sub nfa { my $self = shift; my ($C) = @_; 
        my $alts = $self->{'zyg'};
        ::here(0+@$alts);
        my @out = ( [0, []] );
        my $oldfakepos = $CursorBase::fakepos;
        my $minfakepos = $CursorBase::fakepos + 1;
        my $ix = 0;
        for my $alt (@$alts) {
            $CursorBase::fakepos = $oldfakepos;

            my @subnfa = $alt->nfa($C);
            for my $node (@subnfa) {
                for my $fate (@{ $node->[1] }) {
                    unshift @$fate, $self->{altname}, $ix;
                }
            }
            push @{$out[0]}, '', ::nfarebase(\@out, \@subnfa);

            $minfakepos = $oldfakepos if $CursorBase::fakepos == $oldfakepos;
            $ix++;
        }
        $CursorBase::fakepos = $minfakepos;  # Did all branches advance?
        @out;
    }
}

{ package RE_var; our @ISA = 'REbase';
    #method longest ($C) { ... }
    sub longest { my $self = shift; my ($C) = @_; 
        my $var = $self->{var};
        if (my $p = $C->_PARAMS) {
            my $text = $p->{$var} || return $IMP;
            $CursorBase::fakepos++ if length($text);
            $text = ::qm($text);
            return $text;
        }
        return $IMP;
    }
}

1;
