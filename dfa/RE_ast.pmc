# RE_ast.pmc
#
# Copyright 2009-2010, Larry Wall
#
# You may copy this software under the terms of the Artistic License,
#     version 2.0 or later.

package main;
use utf8;
use strict; use warnings;
use DEBUG;
use Encode;
my $IMP = '(?#::)';
my $DIMP = [[1, [[1]] ]];
my $DNULL = [[0, [[0]] ]];
our $PURIFY = 0;        # ignore {*} IMPs?
our $PREFIX = "";

# The DFA engine has two priorities; top priority is to generate the correct
# pattern prefixes; second is to generate as much fate as it can.

#############################################################
# longest token set generator
#############################################################

#    $::DEBUG |= -1;
sub qm { my $s = shift;
    $s = $s->[0] if ref $s eq 'ARRAY';	# only count first token of circumfix or postcircumfix
    my $r = '';
    for (split(//,$s)) {
	if ($_ eq " ") { $r .= '\x20' }
	elsif ($_ eq "\t") { $r .= '\t' }
	elsif ($_ eq "\n") { $r .= '\n' }
	elsif ($_ =~ m/^\w$/) { $r .= $_ }
	elsif ($_ eq '<' | $_ eq '>') { $r .= $_ }
	else { $r .= '\\' . $_ }
    }
    $r;
}

sub here {
    return unless $::DEBUG & DEBUG::longest_token_pattern_generation;
    my $arg = shift;
    my $lvl = 0;
    while (caller($lvl)) { $lvl++ }
    my ($package, $file, $line, $subname, $hasargs) = caller(0);

    my $name = $package;   # . '::' . substr($subname,1);
    if (defined $arg) { 
	$name .= " " . $arg;
    }
    ::deb("\t", ':' x $lvl, ' ', $name, " [", $file, ":", $line, "]") if $::DEBUG & DEBUG::longest_token_pattern_generation;
}

sub nfarebase { my ($onto, $ary) = @_;
    my $offs = @$onto;

    for my $node (@$ary) {
        my $nnode = [ @$node ];
        for (my $ix = 3; $ix < @$nnode; $ix += 2) {
            $nnode->[$ix] += $offs;
        }
        push @$onto, $nnode;
    }

    $offs;
}

sub nfaprefate { my ($fates, $nfa) = @_;
    my @out = @$nfa;

    for my $onode (@out) {
        $onode = [ @$onode ];
        # Non-accepting can just be copied
        next unless @{$onode->[1]};

        my @nfates;
        for my $f1 (@$fates) {
            if ($f1->[-1]) {
                # Non-extensible fate makes this easy
                push @nfates, $f1;
                next;
            }
            my @f1 = @$f1;
            pop @f1;
            for my $f2 (@{$onode->[1]}) {
                push @nfates, [ @f1, @$f2 ];
            }
        }

        $onode->[1] = \@nfates;
    }

    \@out;
}


sub nfaseq { my ($fst, $sndthunk) = @_;
    my @out = @$fst;
    my $max = @out - 1;

    if (ref $sndthunk ne 'CODE') {
        my $v = $sndthunk;
        $sndthunk = sub { $v };
    }

    for my $j (0 .. $max) {
        # Non-accepting can just be copied
        next unless @{$out[$j][1]};
        $out[$j] = [ @{ $out[$j] } ];
        # Imperative acceptors stay accepting and in the same way
        next if $out[$j][0];
        # Otherwise, we need to glue on a copy of the sequence tail.
        # We could share a single copy of the sequence tail if we were
        # willing to lose deep fating... food for thought.
        push @{$out[$j]}, undef, nfarebase(\@out,
            nfaprefate($out[$j][1], $sndthunk->()));
        $out[$j][1] = [];  # not accepting any more
    }

    \@out;
}

# nfaplus would be possible, but it would be a pessimization from a deep fating
# standpoint
sub nfastar { my ($in) = @_;
    # we can't return fates for any of this stuff as there's no telling how many
    # times though the loop we've gone
    my @out = ( [0, []] );
    nfarebase(\@out, $in);

    # all nodes already cloned by nfarebase
    for my $node (@out) {
        next unless @{ $node->[1] };
        $node->[1] = [];
        push @$node, undef, 0;
    }

    $out[0][1] = [[1]];
    push @{ $out[0] }, undef, 1;
    \@out;
}

sub nfadisj { my @ins = @_;
    my @out = ( [ 0, [] ] );

    for my $in (@ins) {
        push @{ $out[0] }, undef, nfarebase(\@out, $in);
    }

    \@out;
}

sub nfacclass { my @terms = @_;
    return [ [ 0, [], map { $_, 1 } @terms ],
             [ 0, [[0]] ] ];
}

{ package REbase;
    sub longest { my $self = shift; my ($C) = @_;  ::here("UNIMPL @{[ref $self]}"); "$self" }
}

{ package RE_ast; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        ::here();
        local $::ALT = '';
        $self->{'re'}->longest($C);
    }

    sub nfa { my $self = shift; my $C = shift;
        ::here();
        $self->{'re'}->nfa($C);
    }
}

{ package RE_adverb; our @ISA = 'REbase';
    #method longest ($C) { ... }
}

{ package RE_assertion; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        for (scalar($self->{'assert'})) { if ((0)) {}
            elsif ($_ eq '?') {
                my $re = $self->{'re'};
#               $C->deb("\n",::Dump($self)) unless $re;
                if (ref($re) eq 'RE_method_re' and $re->{'name'} eq 'before') {
                    my @result = $re->longest($C);
                    return map { $_ . $IMP } @result;
                }
            }
        }
        return '';
    }

    sub nfa { my ($self, $C) = @_;
        if ($self->{assert} eq '?') {
            my $re = $self->{re};
            return ::nfaseq($re->nfa($C), $DIMP);
        }
        return $DNULL;
    }
}

{ package RE_assertvar; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        return $IMP;
    }
    sub nfa { $DIMP }
}

{ package RE_block; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        return '' if $PURIFY;
        return $IMP;
    }
    sub nfa { $DIMP }
}

{ package RE_bindvar; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; ::here();
        $self->{'atom'}->longest($C);
    }
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'atom'}->nfa($C);
    }
}

{ package RE_bindnamed; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; ::here();
        $self->{'atom'}->longest($C);
    }
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'atom'}->nfa($C);
    }
}

{ package RE_bindpos; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; ::here();
        $self->{'atom'}->longest($C);
    }
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'atom'}->nfa($C);
    }
}

{ package RE_bracket; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; ::here();
        $self->{'re'}->longest($C);
    }
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'re'}->nfa($C);
    }
}

{ package RE_cclass; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; ::here($self->{'text'});
        $CursorBase::fakepos++;
        my $cc = $self->{'text'};
        Encode::_utf8_on($cc);
        $cc =~ s/^\-\[/[^/;
        $cc =~ s/^\+\[/[/;
        $cc =~ s/\s*\.\.\s*/-/g;
        $cc =~ s/\s*//g;
        $cc = "(?i:$cc)" if $self->{i};
        $cc;
    }

    sub _get_char {
        $_[0] =~ s/^\s+//;
        if ($_[0] =~ s/^([^\\])//s) { return ord($1) }
        if ($_[0] =~ s/^\\n//)   { return 10 }
        if ($_[0] =~ s/^\\t//)   { return 9 }
        if ($_[0] =~ s/^\\x\{(.*?)\}//s)   { return hex($1); }
        if ($_[0] =~ s/^\\x(..)//s)   { return hex($1); }
        if ($_[0] =~ s/^\\(.)//s)   { return ord($1) }

        return undef;
    }

    sub nfa { my ($self, $C) = @_; ::here($self->{text});
        $CursorBase::fakepos++;
        my $cc = $self->{'text'};
        Encode::_utf8_on($cc);
        my ($neg, $text) = $cc =~ /^(-?)\[(.*)\]$/s;
        die "whoops! $cc" unless defined $text;

        #XXX this ought to be pre parsed
        my ($ch, $ch2);
        my @chs;
        while (defined ($ch = _get_char($text))) {
            if ($text =~ s/\s*\.\.//) {
                $ch2 = _get_char($text);
            } else {
                $ch2 = $ch;
            }
            push @chs, map { chr $_ } ($ch .. $ch2);
        }

        if ($self->{i}) {
            @chs = map { uc($_), lc($_) } @chs;
        }

        $neg ? ::nfacclass(['ALL', @chs]) : ::nfacclass(map { [$_] } @chs);
    }
}

{ package RE_decl; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_;  return; }
}

{ package RE_double; our @ISA = 'REbase';
    # XXX inadequate for "\n" without interpolation
    sub longest { my $self = shift; my ($C) = @_; 
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        my $fixed = '';
        if ( $text =~ /^(.*?)[\$\@\%\&\{]/ ) {
            $fixed = $1 . $IMP;
        }
        else {
            $fixed = $text;
        }
        if ($fixed ne '') {
            $CursorBase::fakepos++;
            ::qm($fixed);
        }
        $fixed =~ s/([a-zA-Z])/'[' . $1 . chr(ord($1)^32) . ']'/eg if $self->{i};
        $fixed;
    }
}

{ package RE_meta; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        for (scalar($text)) { if ((0)) {}
            elsif ($_ eq '^' or
                   $_ eq '$' or
                   $_ eq '.' or
                   $_ eq '\\w' or
                   $_ eq '\\s' or
                   $_ eq '\\d')
            {
                return $text;
            }
            elsif ($_ eq '\\h') {
                return '[\\x20\\x09\\x0d]';
            }
            elsif ($_ eq '\\v') {
                return '[\\x0a\\x0c]';
            }
            elsif ($_ eq '\\N') {
                return '[^\\x0a]';
            }
            elsif ($_ eq '$$') {
                return '(?:\\x0a|$)';
            }
            elsif ($_ eq ':' or $_ eq '^^') {
                return;
            }
            elsif ($_ eq '»' or $_ eq '>>') {
                return '\b';
            }
            elsif ($_ eq '«' or $_ eq '<<') {
                return '\b';
            }
            elsif ($_ eq '::' or $_ eq ':::' or $_ eq '.*?') {
                return $IMP;
            }
            else {
                return $text;
            }
        }
    }

    my %meta_nfa = (
        '\\\\' => ::nfacclass(['\\']),
        '\D' => ::nfacclass(['ALL', 'Gc/N']),
        '\d' => ::nfacclass(['Gc/N']),
        '\H' => ::nfacclass(['ALL', 'Perl/Blank']),
        '\h' => ::nfacclass(['Perl/Blank']),
        '\N' => ::nfacclass(['ALL', "\n"]),
        '\n' => ::nfacclass(["\n"]),
        '\S' => ::nfacclass(['ALL', 'Space/Y']),
        '\s' => ::nfacclass(['Space/Y']),
        '\V' => ::nfacclass(['ALL', 'Perl/VertSpac']),
        '\v' => ::nfacclass(['Perl/VertSpac']),
        '\W' => ::nfacclass(['ALL', '_', 'Gc/L', 'Gc/N']),
        '\w' => ::nfacclass(['_'], ['Gc/L'], ['Gc/N']),
        '.'  => ::nfacclass(['ALL']),
        '::' => $DIMP,
        ':::' => $DIMP,
        '.*?' => $DIMP,
        '.*' => [ [ 0, [[0]], ['ALL'], 0 ] ],
    );

    sub nfa { my $self = shift; my ($C) = @_; 
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        return $meta_nfa{$text} // die "unhandled meta";
    }
}

{ package RE_method; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        my $name = $self->{'name'};
        return $IMP if $self->{'rest'};
        Encode::_utf8_on($name);
        ::here($name);
        for (scalar($name)) { if ((0)) {}
            elsif ($_ eq 'null') {
                return;
            }
            elsif ($_ eq '') {
                return $IMP;
            }
            elsif ($_ eq 'ws') {
                return $IMP;
            }
            elsif ($_ eq 'sym') {
                $CursorBase::fakepos++;
                my $sym = $self->{'sym'};
                Encode::_utf8_on($sym);
                my $text = ::qm($sym);
                $text =~ s/(\pL)/'[' . lc($1) . uc($1) . ']'/eg if $self->{i};
                return $text;
            }
            elsif ($_ eq 'ww') {
                return '\w' . $IMP;
            }
            elsif ($_ eq 'alpha') {
                $CursorBase::fakepos++;
                return '[_[:alpha:]\pL]';
            }
            my $lexer;
            {
                local $::PREFIX = "";
                $name .= '__PEEK';
                $lexer = eval { $C->$name() };
            }
            return $IMP unless $lexer and exists $lexer->{PATS};
            my @pat = @{$lexer->{PATS}};
            return unless @pat;
            if ($::PREFIX) {
                for (@pat) {
                    s/(\t\(\?#FATE)\d* *(.*?\))(.*)/$3$1$::PREFIX $2/g;
                }
            }
            return @pat;
        }
    }
    sub nfa { my ($self, $C) = @_;
        my $name = $self->{'name'};
        return $IMP if $self->{'rest'};
        Encode::_utf8_on($name);
        ::here($name);

        if ($name eq 'ws') { return $DIMP; }
        if ($name eq 'alpha') { $CursorBase::fakepos++; return ::nfacclass(['_'], ['Gc/L']); }
        if ($name eq 'sym') {
            $CursorBase::fakepos++;
            my $sym = $self->{'sym'};
            Encode::_utf8_on($sym);
            return RE_string::nfa({ i => $self->{i}, text => $sym }, $C);
        }

        $name .= '__PEEK';
        return $DIMP unless $C->can($name);
        my $lexer = $C->$name();
        return $DIMP unless $lexer and exists $lexer->{NFA};
        return $lexer->{NFA};
    }
}

{ package RE_method_internal; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        return $IMP;
    }
    sub nfa { $DIMP }
}

{ package RE_method_re; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        my $name = $self->{'name'};
        Encode::_utf8_on($name);
        ::here($name);
        my $re = $self->{'re'};
        for (scalar($name)) { if ((0)) {}
            elsif ($_ eq '') {
                return $IMP;
            }
            elsif ($_ eq 'after') {
                return;
            }
            elsif ($_ eq 'before') {
                my @result = $re->longest($C);
                return map { $_ . $IMP } @result;
            }
            else {
                $name .= '__PEEK';
                my $lexer = $C->$name($re);
                my @pat = @{$lexer->{PATS}};
                return unless @pat;
                return @pat;
            }
        }
    }

    sub nfa { my ($self, $C) = @_;
        my $name = $self->{name};
        Encode::_utf8_on($name);
        ::here($name);
        my $re = $self->{re};
        if ($name eq '') {
            return $DIMP;
        } elsif ($name eq 'after') {
            return $DNULL;
        } elsif ($name eq 'before') {
            return ::nfaseq($re->nfa($C), $DIMP);
        } else {
            $name .= '__PEEK';
            return $C->$name($re)->{NFA};
        }
    }
}

{ package RE_noop; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        return $IMP;
    }
}

{ package RE_every; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        return $IMP;
    }
    sub nfa { $DIMP }
}

{ package RE_first; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        my $alts = $self->{'zyg'};
        ::here(0+@$alts);
        my @result;
        for my $alt (@$alts) {
            my @pat = $alt->longest($C);
            push @result, @pat;
            last;
        }
        $C->deb(join("\n",@result)) if $::DEBUG & DEBUG::longest_token_pattern_generation;
        @result;
    }
}

{ package RE_paren; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; ::here();
        $self->{'re'}->longest($C);
    }
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'re'}->nfa($C);
    }
}

{ package RE_quantified_atom; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        ::here();
        my $oldfakepos = $CursorBase::fakepos++;
        my $a = $self->{atom};
        my @atom = $a->longest($C);
        return unless @atom;
        my $atom = join('|',@atom);
        return if $atom eq '';
        $atom = "(?:" . $atom . ')' unless $a->{min} == 1 and ref($a) =~ /^RE_(?:meta|cclass|string)/;
        if ($self->{'quant'}[0] eq '+') {
            if (@atom > 1) {
                return map { $_ . $IMP } @atom;
            }
            return "$atom+";
        }
        elsif ($self->{'quant'}[0] eq '*') {
            $CursorBase::fakepos = $oldfakepos;
            if (@atom > 1) {
                return map { $_ . $IMP } @atom,'';
            }
            return "$atom*";
        }
        elsif ($self->{'quant'}[0] eq '?') {
            $CursorBase::fakepos = $oldfakepos;
            if (@atom > 1) {
                return @atom,'';
            }
            return "$atom?";
        }
        elsif ($self->{'quant'}[0] eq '**') {
            my $x = $self->{'quant'}[2];
            if ($x =~ /^\d/) {
                $x =~ s/\.\./,/;
                $x =~ s/\*//;
                $CursorBase::fakepos = $oldfakepos if $x =~ m/^0/;
                return $atom . "{$x}";
            }
            else {
                return $atom . $IMP;
            }
        }
        return $IMP;
    }

    sub nfa { my ($self, $C) = @_; ::here();
        my $oldfakepos = $CursorBase::fakepos++;
        my $subnfa = $self->{atom}->nfa($C);
        #return $DIMP if $self->{quant}[1];  XXX viv omits this currently
        # XXX S05 is not quite clear; it could be read as saying to cut LTM
        # *after* the atom
        return $DIMP if $self->{quant}[2]
            && $self->{quant}[2]->isa('RE_block');

        my $k = $self->{quant}[0];
        if ($k eq '?') {
            return ::nfadisj($DNULL, $subnfa);
        } elsif ($k eq '*') {
            return ::nfastar($subnfa);
        } elsif ($k eq '+') {
            return ::nfaseq($subnfa, ::nfastar($subnfa));
        } elsif ($k eq '**') {
            my $subnfa2 = $self->{quant}[2]->nfa($C);
            return ::nfaseq($subnfa, ::nfastar(::nfaseq($subnfa2, $subnfa)));
        } else {
            die "unknown quantifier $k";
        }
    }
}

{ package RE_qw; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        $CursorBase::fakepos++;
        $text =~ s/^<\s*//;
        $text =~ s/\s*>$//;
        $text =~ s/\s+/|/;
        '(?: ' . $text . ')';
    }
}

{ package RE_sequence; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        my $result = [''];
        my $c = $self->{'zyg'};
        my @chunks = @$c;
        ::here(0+@chunks);
        local $::PREFIX = $::PREFIX;

        for my $chunk (@chunks) {
            # ignore negative lookahead
            next if ref($chunk) eq 'RE_assertion' and $chunk->{assert} eq '!';
            $C->deb("NULLABLE ".ref($chunk)) if $::DEBUG & DEBUG::longest_token_pattern_generation and not $chunk->{min};
            my @newalts = $chunk->longest($C);
            last unless @newalts;
#           if (not $chunk->{min} and $next[-1] ne '') {
#               push(@next, '');        # install bypass around nullable atom
#           }
            my $newresult = [];
            my $pure = 0;
            for my $oldalt (@$result) {
                if ($oldalt =~ /\(\?#::\)/) {
                    push(@$newresult, $oldalt);
                    next;
                }

                for my $newalt (@newalts) {
                    $pure = 1 unless $newalt =~ /\(\?#::\)/;
#                   $::PREFIX = '' if $newalt =~ /FATE/;;
                    if ($oldalt =~ /FATE/ and $newalt =~ /FATE/) {
                        my $newold = $oldalt;
                        my $newnew = $newalt;
                        $newnew =~ s/\t\(\?#FATE\d* *(.*?)\)//;
                        my $morefate = $1;
                        $newold =~ s/(FATE.*?)\)/$1 $morefate)/;
                        push(@$newresult, $newold . $newnew);
                    }
                    else {
                        push(@$newresult, $oldalt . $newalt);
                    }
                }
            }
            $result = $newresult;
            last unless $pure;  # at least one alternative was pure
            # ignore everything after positive lookahead
            last if ref($chunk) eq 'RE_assertion';
        }
        @$result;
    }

    sub _nfa_recurse { my ($self, $C, $ix, $cache) = @_;
        if ($ix == @{$self->{zyg}}) {
            return $DNULL;
        }

        ::nfaseq($self->{zyg}[$ix]->nfa($C),
            sub { $cache->[$ix+1] //= $self->_nfa_recurse($C, $ix+1, $cache); });
    }

    sub nfa { my ($self, $C) = @_; ::here;
        my @cache;
        $self->_nfa_recurse($C, 0, \@cache);
    }
}

{ package RE_string; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        $CursorBase::fakepos++ if $self->{'min'};
        $text = ::qm($text);
        $text =~ s/([[:alpha:]])/'[' . $1 . chr(ord($1)^32) . ']'/eg if $self->{i};
        $text;
    }
    sub nfa { my ($self, $C) = @_;
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        $CursorBase::fakepos++ if $self->{'min'};
        die "UNIMPL" if $self->{i};
        my @nfa;
        for (split //, $text) {
            push @nfa, [ 0, [], [$_], @nfa+1 ];
        }
        [ @nfa, [ 0, [[0]] ] ];
    }
}

{ package RE_submatch; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        return $IMP;
    }
    sub nfa { $DIMP }
}

{ package RE_all; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        return $IMP;
    }
    sub nfa { $DIMP }
}

{ package RE_any; our @ISA = 'REbase';
    sub longest { my $self = shift; my ($C) = @_; 
        my $alts = $self->{'zyg'};
        ::here(0+@$alts);
        my @result;
        my $oldfakepos = $CursorBase::fakepos;
        my $minfakepos = $CursorBase::fakepos + 1;
        my $base = $::ALT // '';
        $base .= ' ' if $base;
        my %autolexbase = %::AUTOLEXED;
        for my $alt (@$alts) {
            local %::AUTOLEXED = %autolexbase;    # alts are independent
            $CursorBase::fakepos = $oldfakepos;
            local $::ALT = $base . $alt->{alt};
            {
                local $::PREFIX = $::PREFIX . ' ' . $::ALT;
                my @pat = ($alt->longest($C));
                push @result, map { /#FATE/ or s/$/\t(?#FATE $::PREFIX)/; $_ } @pat;
            }
            $minfakepos = $oldfakepos if $CursorBase::fakepos == $oldfakepos;
        }
        $C->deb(join("\n", @result)) if $::DEBUG & DEBUG::longest_token_pattern_generation;
        $CursorBase::fakepos = $minfakepos;  # Did all branches advance?
        @result;
    }

    sub nfa { my $self = shift; my ($C) = @_; 
        my $alts = $self->{'zyg'};
        ::here(0+@$alts);
        my @outs;
        my $oldfakepos = $CursorBase::fakepos;
        my $minfakepos = $CursorBase::fakepos + 1;
        my $ix = 0;
        
        for my $alt (@$alts) {
            $CursorBase::fakepos = $oldfakepos;

            push @outs, ::nfaprefate([[$self->{altname}, $ix, 0]], $alt->nfa($C));

            $minfakepos = $oldfakepos if $CursorBase::fakepos == $oldfakepos;
            $ix++;
        }
        $CursorBase::fakepos = $minfakepos;  # Did all branches advance?
        ::nfadisj(@outs);
    }
}

{ package RE_var; our @ISA = 'REbase';
    #method longest ($C) { ... }
    sub longest { my $self = shift; my ($C) = @_; 
        my $var = $self->{var};
        if (my $p = $C->_PARAMS) {
            my $text = $p->{$var} || return $IMP;
            $CursorBase::fakepos++ if length($text);
            $text = ::qm($text);
            return $text;
        }
        return $IMP;
    }
}

1;
