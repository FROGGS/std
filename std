#!/usr/bin/env perl

BEGIN {
    use FindBin;
    use File::Spec;
    my @inc = ($FindBin::Bin);
    if (@ARGV >= 1 && $ARGV[0] eq '--boot') {
        shift @ARGV;
        unshift @INC, File::Spec->catdir($FindBin::Bin, "boot");
        $CursorBase::SET_STD5PREFIX = "boot";
    }
    if (@ARGV >= 1 && $ARGV[0] eq '--clear-inc') {
        $CursorBase::SET_PERL6LIB = [ ];
        shift @ARGV;
    }
    while (@ARGV >= 2 && $ARGV[0] eq '--inc') {
        push @$CursorBase::SET_PERL6LIB, $ARGV[1];
        splice @ARGV, 0, 2;
    }
}

use STD;
use utf8;

use Actions;

my $failures = 0;

@ARGV = 'CORE.setting' unless @ARGV;

for my $file (@ARGV) {
    warn $file,"\n" if @ARGV > 1;
    my $setting = "CORE";
    $setting = "NULL" if $file eq 'CORE.setting';
    my $r;
    eval {
        $r = STD->parsefile($file, setting => $setting, actions => 'Actions')->{'_ast'};
    };
    if ($@) {
	warn $@;
	$failures++;
    }
}
my ($time, $vsz) = split(' ', `ps -o "time= vsz=" $$`);
$time =~ s/^00://;
$vsz =~ s/\d\d\d$/m/;
if ($failures) {
    if ($vsz) {
	warn "std FAILED $time $vsz @ARGV\n";
    }
    else {
	warn "std FAILED @ARGV\n";
    }
    exit $failures;
}
elsif ($vsz) {
    warn "ok $time $vsz @ARGV\n";
}
else {
    warn "ok @ARGV\n";
}

{ package VAST::Additive; }
{ package VAST::Autoincrement; }
{ package VAST::Base; }
{ package VAST::Chaining; }
{ package VAST::Comma; }
{ package VAST::Concatenation; }
{ package VAST::Conditional; }
{ package VAST::Exponentiation; }
{ package VAST::Item_assignment; }
{ package VAST::Junctive_and; }
{ package VAST::Junctive_or; }
{ package VAST::List_assignment; }
{ package VAST::List_infix; }
{ package VAST::List_prefix; }
{ package VAST::Loose_and; }
{ package VAST::Loose_or; }
{ package VAST::Loose_unary; }
{ package VAST::Methodcall; }
{ package VAST::Multiplicative; }
{ package VAST::Named_unary; }
{ package VAST::Replication; }
{ package VAST::Sequencer; }
{ package VAST::Structural_infix; }
{ package VAST::Symbolic_unary; }
{ package VAST::Term; }
{ package VAST::Tight_and; }
{ package VAST::Tight_or; }
