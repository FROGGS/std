# RE_ast.pmc
#
# Copyright 2009-2010, Larry Wall
#
# You may copy this software under the terms of the Artistic License,
#     version 2.0 or later.

package main;
use utf8;
use strict; use warnings;
use DEBUG;
use Encode;

# The DFA engine has two priorities; top priority is to generate the correct
# pattern prefixes; second is to generate as much fate as it can.

# [conjectural]
# We use two data structures to represent NFAs.  The NFA description tree
# (NFA::* but not NFA::Node, NFA::Lazy) is statically built; it is a near 1:1
# mapping of the RE_ast structure.  The NFA description tree is used to
# generate the NFA construction tree, which is lazily built.
{
    package NFA::Lazy;
    sub new   { bless [ @_ ], 'NFA::Lazy' }
    sub reify {
        my $self = shift;
        my ($node, $prefix, $continue) = splice @$self;
        bless $self, 'NFA::Node';
        $node->construct($self, $prefix, $continue);
    }
}

{
    package NFA::Node;
    sub reify { }
}

{
    package NFA::seq;
    sub new {
        my ($left, $right) = @_;
        my $literal = $left->{literal};
        my $litlen  = $left->{litlen};
        if ($literal) {
            $literal &&= $right->{literal};
            $litlen  +=  ($right->{litlen} // 0);
        }
        bless { left => $left, right => $right, literal => $literal,
            litlen => $litlen, fates => ($left->{fates} || $right->{fates}) },
            'NFA::seq';
    }

    sub construct {
        my ($self, $node, $pre_fates, $continue) = @_;

        $self->{left}->construct($node, $pre_fates, sub {
                my $mid_fates = shift;
                NFA::Lazy->new($self->{right}, $mid_fates, $continue);
            });
    }
}

#############################################################
# longest token set generator
#############################################################

#    $::DEBUG |= -1;
sub qm { my $s = shift;
    $s = $s->[0] if ref $s eq 'ARRAY';	# only count first token of circumfix or postcircumfix
    my $r = '';
    for (split(//,$s)) {
	if ($_ eq " ") { $r .= '\x20' }
	elsif ($_ eq "\t") { $r .= '\t' }
	elsif ($_ eq "\n") { $r .= '\n' }
	elsif ($_ =~ m/^\w$/) { $r .= $_ }
	elsif ($_ eq '<' | $_ eq '>') { $r .= $_ }
	else { $r .= '\\' . $_ }
    }
    $r;
}

sub here {
    return unless $::DEBUG & DEBUG::longest_token_pattern_generation;
    my $arg = shift;
    my $lvl = 0;
    while (caller($lvl)) { $lvl++ }
    my ($package, $file, $line, $subname, $hasargs) = caller(0);

    my $name = $package;   # . '::' . substr($subname,1);
    if (defined $arg) { 
	$name .= " " . $arg;
    }
    ::deb("\t", ':' x $lvl, ' ', $name, " [", $file, ":", $line, "]") if $::DEBUG & DEBUG::longest_token_pattern_generation;
}

{ package nfa;

our $NULL = [[ undef,  [0] ]];
our $IMP  = [[ {I=>1}, [1] ]];

sub rebase { my ($onto, $ary) = @_;
    my $offs = @$onto;

    for my $node (@$ary) {
        my $nnode = [ @$node ];
        for (my $ix = 3; $ix < @$nnode; $ix += 2) {
            $nnode->[$ix] += $offs;
        }
        push @$onto, $nnode;
    }

    $offs;
}

sub prefate { my ($fate, $nfa) = @_;
    my @out = @$nfa;

    for my $onode (@out) {
        $onode = [ @$onode ];
        # Non-accepting can just be copied
        next unless $onode->[1];

        if ($fate->[-1]) {
            # Non-extensible fate makes this easy
            $onode->[1] = $fate;
        } else {
            my @f = @$fate;
            pop @f;
            $onode->[1] = [ @f, @{ $onode->[1] } ];
        }
    }

    \@out;
}

sub ltmprefate { my ($tag, $val, $tb, $inner) = @_;
    my $ord = pack("NN", (~($inner->[0][0]{LITLEN} // 0)), $tb);
    prefate([ $tag, $val, $ord, 0 ], $inner);
}

# When a non-LTM alternation or quantifier is applied to a subregex, it becomes
# impossible to control where subsequent tokens match, so we can't copy fates.
sub horizon { my ($inner) = @_;
    prefate([ 1 ], $inner);
}

sub has_nontrivial_fates { my ($inner) = @_;
    my $ok = 1;
    NODE: for my $n (@$inner) {
        if (my $fate = $n->[1]) {
            if ((@$fate > 1) || $fate->[0]) {
                $ok = 0;
                last NODE;
            }
        }
    }
    !$ok;
}

sub seq { my ($fst, $sndthunk) = @_;
    my @out = @$fst;
    my $max = @out - 1;

    if (ref $sndthunk ne 'CODE') {
        my $v = $sndthunk;
        $sndthunk = sub { $v };
    }

    for my $j (0 .. $max) {
        # Non-accepting can just be copied
        next unless $out[$j][1];
        $out[$j] = [ @{ $out[$j] } ];
        # Imperative acceptors stay accepting and in the same way
        next if $out[$j][0]{I};
        # Otherwise, we need to glue on a copy of the sequence tail.
        # We could share a single copy of the sequence tail if we were
        # willing to lose deep fating... food for thought.
        push @{$out[$j]}, undef, rebase(\@out,
            prefate($out[$j][1], $sndthunk->()));
        $out[$j][1] = undef;  # not accepting any more
    }

    if ($out[0][0]{LITERAL}) {
        $out[0][0] = { %{ $out[0][0] } } if $out[0][0];
        my $n = $sndthunk->()->[0][0];
        $out[0][0]{LITERAL} &&= $n->{LITERAL};
        $out[0][0]{LITLEN} += ($n->{LITLEN} // 0);
    }

    \@out;
}

# plus would be possible, but it would be a pessimization from a deep fating
# standpoint
sub star { my ($in) = @_;
    my @out = ( [undef, undef] );
    rebase(\@out, $in);
    my $fate = [ 1 ];

    # all nodes already cloned by nfarebase
    for my $node (@out) {
        next unless $node->[1];
        if ($node->[0]{I}) {
            $node->[1] = $fate;
            next;
        }
        $node->[1] = undef;
        push @$node, undef, 0;
    }

    $out[0][1] = $fate;
    push @{ $out[0] }, undef, 1;
    \@out;
}

sub opt { my ($in) = @_;
    my @out = ( [undef, undef, undef, 1, undef, 2], [undef, undef] );

    my $fate = [ 1 ];
    rebase(\@out, $in);

    # all nodes already cloned by nfarebase
    for my $node (@out) {
        next unless $node->[1];
        if ($node->[0]{I}) {
            $node->[1] = $fate;
            next;
        }
        $node->[1] = undef;
        push @$node, undef, 1;
    }

    $out[1][1] = $fate;
    \@out;
}

sub disj { my @ins = @_;
    my @out = ( [ undef, undef ] );

    for my $in (@ins) {
        push @{ $out[0] }, undef, rebase(\@out, $in);
    }

    \@out;
}

sub cclass { my @terms = @_;
    return [ [ undef, undef, map { $_, 1 } @terms ],
             [ undef, [0] ] ];
}

sub string { my ($i, $text) = @_;
    my @nfa;
    for my $c (split //, $text) {
        my @e = $i ? (lc($c), uc($c)) : ($c);
        push @nfa, [ undef, undef, map {[$_], @nfa+1} @e ];
    }
    $nfa[0][0]{LITERAL} = 1;
    $nfa[0][0]{LITLEN} = length($text);
    [ @nfa, [ undef, [0] ] ];
}
}

my $IMP = $nfa::IMP;
my $NULL = $nfa::NULL;

{ package REbase;
}

{ package RE_ast; our @ISA = 'REbase';
    sub nfa { my $self = shift; my $C = shift;
        ::here();
        $self->{'re'}->nfa($C);
    }
}

{ package RE_assertion; our @ISA = 'REbase';
    sub nfa { my ($self, $C) = @_;
        if ($self->{assert} eq '?') {
            my $re = $self->{re};
            return nfa::seq($re->nfa($C), $IMP);
        }
        return $NULL;
    }
}

{ package RE_assertvar; our @ISA = 'REbase';
    sub nfa { $IMP }
}

{ package RE_block; our @ISA = 'REbase';
    sub nfa { $IMP }
}

{ package RE_bindvar; our @ISA = 'REbase';
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'atom'}->nfa($C);
    }
}

{ package RE_bindnamed; our @ISA = 'REbase';
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'atom'}->nfa($C);
    }
}

{ package RE_bindpos; our @ISA = 'REbase';
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'atom'}->nfa($C);
    }
}

{ package RE_bracket; our @ISA = 'REbase';
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'re'}->nfa($C);
    }
}

{ package RE_cclass; our @ISA = 'REbase';
    sub _get_char {
        if ($_[0] =~ s/^([^\\])//s) { return ord($1) }
        if ($_[0] =~ s/^\\n//)   { return 10 }
        if ($_[0] =~ s/^\\t//)   { return 9 }
        if ($_[0] =~ s/^\\x\{(.*?)\}//s)   { return hex($1); }
        if ($_[0] =~ s/^\\x(..)//s)   { return hex($1); }
        if ($_[0] =~ s/^\\(.)//s)   { return ord($1) }

        return undef;
    }

    sub nfa { my ($self, $C) = @_; ::here($self->{text});
        $CursorBase::fakepos++;
        my $cc = $self->{'text'};
        Encode::_utf8_on($cc);
        my ($neg, $text) = $cc =~ /^(-?)\[(.*)\]$/s;
        die "whoops! $cc" unless defined $text;

        #XXX this ought to be pre parsed
        my ($ch, $ch2);
        my @chs;
        while (1) {
            $text =~ s/^\s+//;
            if ($text =~ s/^\\s//) {
                push @chs, 'Space/Y';
                next;
            }
            if ($text =~ s/^\\w//) {
                push @chs, '_', 'Gc/L', 'Gc/N';
                next;
            }
            last if $text eq '';
            $ch = _get_char($text);
            if ($text =~ s/^\s*\.\.//) {
                $ch2 = _get_char($text);
            } else {
                $ch2 = $ch;
            }
            push @chs, map { chr $_ } ($ch .. $ch2);
        }

        if ($self->{i}) {
            @chs = map { uc($_), lc($_) } @chs;
        }

        $neg ? nfa::cclass(['ALL', @chs]) : nfa::cclass(map { [$_] } @chs);
    }
}

{ package RE_decl; our @ISA = 'REbase';
    sub nfa { $NULL }
}

{ package RE_double; our @ISA = 'REbase';
    # XXX inadequate for "\n" without interpolation
    sub nfa { my ($self, $C) = @_;
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        $Cursor::fakepos++ if $text ne '';
        my ($fixed, $imp);
        if ( $text =~ /^(.*?)[\$\@\%\&\{]/ ) {
            $fixed = $1; $imp = 1;
        }
        else {
            $fixed = $text;
        }
        $fixed = nfa::string($self->{i}, $fixed);
        $fixed = nfa::seq($fixed, $IMP) if $imp;
        $fixed;
    }
}

{ package RE_meta; our @ISA = 'REbase';
    my %meta_nfa = (
        # XXX I don't think these are quite right
        '^' => $NULL, '^^' => $NULL, '$$' => $NULL, '$' => $NULL,
        '«' => $NULL, '<<' => $NULL, '>>' => $NULL, '»' => $NULL,
        # what?
        '\\\\' => nfa::cclass(['\\']),
        '\\"' =>  nfa::cclass(['"']),
        '\\\'' => nfa::cclass(["'"]),
        '\D' =>   nfa::cclass(['ALL', 'Gc/N']),
        '\d' =>   nfa::cclass(['Gc/N']),
        '\H' =>   nfa::cclass(['ALL', 'Perl/Blank']),
        '\h' =>   nfa::cclass(['Perl/Blank']),
        '\N' =>   nfa::cclass(['ALL', "\n"]),
        '\n' =>   nfa::cclass(["\n"]),
        '\S' =>   nfa::cclass(['ALL', 'Space/Y']),
        '\s' =>   nfa::cclass(['Space/Y']),
        '\V' =>   nfa::cclass(['ALL', 'Perl/VertSpac']),
        '\v' =>   nfa::cclass(['Perl/VertSpac']),
        '\W' =>   nfa::cclass(['ALL', '_', 'Gc/L', 'Gc/N']),
        '\w' =>   nfa::cclass(['_'], ['Gc/L'], ['Gc/N']),
        '.'  =>   nfa::cclass(['ALL']),
        '::' =>   $IMP,
        ':::' =>  $IMP,
        '.*?' =>  $IMP,
        '.*' =>   nfa::star(nfa::cclass(['ALL'])),
    );

    sub nfa { my $self = shift; my ($C) = @_; 
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        return $meta_nfa{$text} // die "unhandled meta $text";
    }
}

{ package RE_method; our @ISA = 'REbase';
    sub nfa { my ($self, $C) = @_;
        my $name = $self->{'name'};
        return $IMP if $self->{'rest'};
        Encode::_utf8_on($name);
        ::here($name);

        if ($name eq 'null' or $name eq 'ww') { return $NULL }
        if ($name eq 'ws') { return $IMP; }
        if ($name eq 'alpha') { $CursorBase::fakepos++; return nfa::cclass(['_'], ['Gc/L']); }
        if ($name eq 'sym') {
            $CursorBase::fakepos++;
            my $sym = $self->{'sym'};
            Encode::_utf8_on($sym);
            return nfa::string($self->{i}, $sym);
        }

        # XXX
        $name = 'termish' if $name eq 'EXPR';

        $::usedmethods{$name} = 1;
        $name .= '__PEEK';
        return $IMP unless $C->can($name);
        my $lexer = $C->$name();
        %::usedmethods = (%::usedmethods, %{ $lexer->{USED_METHODS} });
        return $IMP unless $lexer and exists $lexer->{NFA};
        return $lexer->{NFA};
    }
}

{ package RE_method_internal; our @ISA = 'REbase';
    sub nfa { $IMP }
}

{ package RE_method_re; our @ISA = 'REbase';
    sub nfa { my ($self, $C) = @_;
        my $name = $self->{name};
        Encode::_utf8_on($name);
        ::here($name);
        my $re = $self->{re};
        if ($name eq '') {
            return $IMP;
        } elsif ($name eq 'after') {
            return $NULL;
        } elsif ($name eq 'before') {
            return nfa::seq($re->nfa($C), $IMP);
        } else {
            $::usedmethods{$name} = 1;
            $name .= '__PEEK';
            my $lexer = $C->$name($re);
            %::usedmethods = (%::usedmethods, %{ $lexer->{USED_METHODS} });
            return $lexer->{NFA};
        }
    }
}

{ package RE_noop; our @ISA = 'REbase';
    sub nfa { $NULL }
}

{ package RE_every; our @ISA = 'REbase';
    sub nfa { $IMP }
}

{ package RE_first; our @ISA = 'REbase';
    sub nfa { my ($self, $C) = @_;
        my $alts = $self->{'zyg'};
        ::here(0+@$alts);
        nfa::horizon($alts->[0]->nfa($C));
    }
}

{ package RE_paren; our @ISA = 'REbase';
    sub nfa { my $self = shift; my $C = shift; ::here();
        $self->{'re'}->nfa($C);
    }
}

{ package RE_quantified_atom; our @ISA = 'REbase';
    sub nfa { my ($self, $C) = @_; ::here();
        my $oldfakepos = $CursorBase::fakepos++;
        my $subnfa = $self->{atom}->nfa($C);
        #return $IMP if $self->{quant}[1];  XXX viv omits this currently
        # XXX S05 is not quite clear; it could be read as saying to cut LTM
        # *after* the atom
        return $IMP if $self->{quant}[2]
            && $self->{quant}[2]->isa('RE_block');

        my $k = $self->{quant}[0];
        if ($k eq '?') {
            return nfa::opt($subnfa);
        } elsif ($k eq '*') {
            return nfa::star($subnfa);
        } elsif ($k eq '+') {
            return nfa::seq($subnfa, nfa::star($subnfa));
        } elsif ($k eq '**') {
            my $subnfa2 = $self->{quant}[2]->nfa($C);
            return nfa::seq($subnfa, nfa::star(nfa::seq($subnfa2, $subnfa)));
        } else {
            die "unknown quantifier $k";
        }
    }
}

{ package RE_qw; our @ISA = 'REbase';
    sub nfa { my ($self, $C) = @_;
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        $CursorBase::fakepos++;
        $text =~ s/^<\s*//;
        $text =~ s/\s*>$//;

        nfa::horizon(nfa::disj(map { nfa::string($self->{i}, $_) } split(/\s+/, $text)));
    }
}

{ package RE_sequence; our @ISA = 'REbase';
    sub _nfa_recurse { my ($self, $C, $ix, $cache) = @_;
        if ($ix == @{$self->{zyg}}) {
            return $NULL;
        }

        nfa::seq($self->{zyg}[$ix]->nfa($C),
            sub { $cache->[$ix+1] //= $self->_nfa_recurse($C, $ix+1, $cache); });
    }

    sub nfa { my ($self, $C) = @_; ::here;
        my @cache;
        $self->_nfa_recurse($C, 0, \@cache);
    }
}

{ package RE_string; our @ISA = 'REbase';
    sub nfa { my ($self, $C) = @_;
        my $text = $self->{'text'};
        Encode::_utf8_on($text);
        ::here($text);
        $CursorBase::fakepos++ if $text ne '';
        nfa::string($self->{i}, $text);
    }
}

{ package RE_submatch; our @ISA = 'REbase';
    sub nfa { $IMP }
}

{ package RE_all; our @ISA = 'REbase';
    sub nfa { $IMP }
}

{ package RE_any; our @ISA = 'REbase';
    sub nfa { my $self = shift; my ($C) = @_; 
        my $alts = $self->{'zyg'};
        ::here(0+@$alts);
        my @outs;
        my $oldfakepos = $CursorBase::fakepos;
        my $minfakepos = $CursorBase::fakepos + 1;
        my $ix = 0;
        
        for my $alt (@$alts) {
            $CursorBase::fakepos = $oldfakepos;

            push @outs, nfa::ltmprefate($self->{altname}, $ix, $ix, $alt->nfa($C));

            $minfakepos = $oldfakepos if $CursorBase::fakepos == $oldfakepos;
            $ix++;
        }
        $CursorBase::fakepos = $minfakepos;  # Did all branches advance?
        nfa::disj(@outs);
    }
}

{ package RE_var; our @ISA = 'REbase';
    sub nfa { my ($self, $C) = @_;
        my $var = $self->{var};
        if (my $p = $C->_PARAMS) {
            my $text = $p->{$var} || return $IMP;
            $CursorBase::fakepos++ if length($text);
            return nfa::string($self->{i}, $text);
        }
        return $IMP;
    }
}

1;
